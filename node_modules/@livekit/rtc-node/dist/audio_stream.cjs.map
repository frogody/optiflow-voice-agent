{"version":3,"sources":["../src/audio_stream.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { Mutex } from '@livekit/mutex';\nimport { AudioFrame } from './audio_frame.js';\nimport type { FfiEvent } from './ffi_client.js';\nimport { FfiClient, FfiClientEvent, FfiHandle } from './ffi_client.js';\nimport type { AudioStreamInfo, NewAudioStreamResponse } from './proto/audio_frame_pb.js';\nimport { AudioStreamType, NewAudioStreamRequest } from './proto/audio_frame_pb.js';\nimport type { Track } from './track.js';\n\nexport interface AudioStreamOptions {\n  noiseCancellation?: NoiseCancellationOptions;\n  sampleRate?: number;\n  numChannels?: number;\n}\n\nexport interface NoiseCancellationOptions {\n  moduleId: string;\n  options: Record<string, any>;\n}\n\nexport class AudioStream implements AsyncIterableIterator<AudioFrame> {\n  /** @internal */\n  info: AudioStreamInfo;\n  /** @internal */\n  ffiHandle: FfiHandle;\n  /** @internal */\n  eventQueue: (AudioFrame | null)[] = [];\n  /** @internal */\n  queueResolve: ((value: IteratorResult<AudioFrame>) => void) | null = null;\n  /** @internal */\n  mutex = new Mutex();\n\n  track: Track;\n  sampleRate: number;\n  numChannels: number;\n  ncOptions?: NoiseCancellationOptions;\n\n  constructor(track: Track);\n  constructor(track: Track, sampleRate: number);\n  constructor(track: Track, sampleRate: number, numChannels: number);\n  constructor(track: Track, options: AudioStreamOptions);\n\n  constructor(\n    track: Track,\n    sampleRateOrOptions?: number | AudioStreamOptions,\n    numChannels?: number,\n  ) {\n    this.track = track;\n    if (sampleRateOrOptions !== undefined && typeof sampleRateOrOptions !== 'number') {\n      this.sampleRate = sampleRateOrOptions.sampleRate ?? 48000;\n      this.numChannels = sampleRateOrOptions.numChannels ?? 1;\n      this.ncOptions = sampleRateOrOptions.noiseCancellation;\n    } else {\n      this.sampleRate = (sampleRateOrOptions as number) ?? 48000;\n      this.numChannels = numChannels ?? 1;\n    }\n\n    const req = new NewAudioStreamRequest({\n      type: AudioStreamType.AUDIO_STREAM_NATIVE,\n      trackHandle: track.ffi_handle.handle,\n      sampleRate: this.sampleRate,\n      numChannels: this.numChannels,\n      ...(this.ncOptions\n        ? {\n            audioFilterModuleId: this.ncOptions.moduleId,\n            audioFilterOptions: JSON.stringify(this.ncOptions.options),\n          }\n        : {}),\n    });\n\n    const res = FfiClient.instance.request<NewAudioStreamResponse>({\n      message: {\n        case: 'newAudioStream',\n        value: req,\n      },\n    });\n\n    this.info = res.stream!.info!;\n    this.ffiHandle = new FfiHandle(res.stream!.handle!.id!);\n\n    FfiClient.instance.on(FfiClientEvent.FfiEvent, this.onEvent);\n  }\n\n  private onEvent = (ev: FfiEvent) => {\n    if (\n      ev.message.case != 'audioStreamEvent' ||\n      ev.message.value.streamHandle != this.ffiHandle.handle\n    ) {\n      return;\n    }\n\n    const streamEvent = ev.message.value.message;\n    switch (streamEvent.case) {\n      case 'frameReceived':\n        const frame = AudioFrame.fromOwnedInfo(streamEvent.value.frame!);\n        if (this.queueResolve) {\n          this.queueResolve({ done: false, value: frame });\n          this.queueResolve = null;\n        } else {\n          this.eventQueue.push(frame);\n        }\n        break;\n      case 'eos':\n        FfiClient.instance.off(FfiClientEvent.FfiEvent, this.onEvent);\n        break;\n    }\n  };\n\n  async next(): Promise<IteratorResult<AudioFrame>> {\n    const unlock = await this.mutex.lock();\n    if (this.eventQueue.length > 0) {\n      unlock();\n      const value = this.eventQueue.shift();\n      if (value) {\n        return { done: false, value };\n      } else {\n        return { done: true, value: undefined };\n      }\n    }\n    const promise = new Promise<IteratorResult<AudioFrame>>(\n      (resolve) => (this.queueResolve = resolve),\n    );\n    unlock();\n    return promise;\n  }\n\n  close() {\n    this.eventQueue.push(null);\n    this.ffiHandle.dispose();\n  }\n\n  [Symbol.asyncIterator](): AudioStream {\n    return this;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,mBAAsB;AACtB,yBAA2B;AAE3B,wBAAqD;AAErD,4BAAuD;AAchD,MAAM,YAAyD;AAAA,EAsBpE,YACE,OACA,qBACA,aACA;AApBF;AAAA,sBAAoC,CAAC;AAErC;AAAA,wBAAqE;AAErE;AAAA,iBAAQ,IAAI,mBAAM;AAqDlB,SAAQ,UAAU,CAAC,OAAiB;AAClC,UACE,GAAG,QAAQ,QAAQ,sBACnB,GAAG,QAAQ,MAAM,gBAAgB,KAAK,UAAU,QAChD;AACA;AAAA,MACF;AAEA,YAAM,cAAc,GAAG,QAAQ,MAAM;AACrC,cAAQ,YAAY,MAAM;AAAA,QACxB,KAAK;AACH,gBAAM,QAAQ,8BAAW,cAAc,YAAY,MAAM,KAAM;AAC/D,cAAI,KAAK,cAAc;AACrB,iBAAK,aAAa,EAAE,MAAM,OAAO,OAAO,MAAM,CAAC;AAC/C,iBAAK,eAAe;AAAA,UACtB,OAAO;AACL,iBAAK,WAAW,KAAK,KAAK;AAAA,UAC5B;AACA;AAAA,QACF,KAAK;AACH,sCAAU,SAAS,IAAI,iCAAe,UAAU,KAAK,OAAO;AAC5D;AAAA,MACJ;AAAA,IACF;AA3DE,SAAK,QAAQ;AACb,QAAI,wBAAwB,UAAa,OAAO,wBAAwB,UAAU;AAChF,WAAK,aAAa,oBAAoB,cAAc;AACpD,WAAK,cAAc,oBAAoB,eAAe;AACtD,WAAK,YAAY,oBAAoB;AAAA,IACvC,OAAO;AACL,WAAK,aAAc,uBAAkC;AACrD,WAAK,cAAc,eAAe;AAAA,IACpC;AAEA,UAAM,MAAM,IAAI,4CAAsB;AAAA,MACpC,MAAM,sCAAgB;AAAA,MACtB,aAAa,MAAM,WAAW;AAAA,MAC9B,YAAY,KAAK;AAAA,MACjB,aAAa,KAAK;AAAA,MAClB,GAAI,KAAK,YACL;AAAA,QACE,qBAAqB,KAAK,UAAU;AAAA,QACpC,oBAAoB,KAAK,UAAU,KAAK,UAAU,OAAO;AAAA,MAC3D,IACA,CAAC;AAAA,IACP,CAAC;AAED,UAAM,MAAM,4BAAU,SAAS,QAAgC;AAAA,MAC7D,SAAS;AAAA,QACP,MAAM;AAAA,QACN,OAAO;AAAA,MACT;AAAA,IACF,CAAC;AAED,SAAK,OAAO,IAAI,OAAQ;AACxB,SAAK,YAAY,IAAI,4BAAU,IAAI,OAAQ,OAAQ,EAAG;AAEtD,gCAAU,SAAS,GAAG,iCAAe,UAAU,KAAK,OAAO;AAAA,EAC7D;AAAA,EA2BA,MAAM,OAA4C;AAChD,UAAM,SAAS,MAAM,KAAK,MAAM,KAAK;AACrC,QAAI,KAAK,WAAW,SAAS,GAAG;AAC9B,aAAO;AACP,YAAM,QAAQ,KAAK,WAAW,MAAM;AACpC,UAAI,OAAO;AACT,eAAO,EAAE,MAAM,OAAO,MAAM;AAAA,MAC9B,OAAO;AACL,eAAO,EAAE,MAAM,MAAM,OAAO,OAAU;AAAA,MACxC;AAAA,IACF;AACA,UAAM,UAAU,IAAI;AAAA,MAClB,CAAC,YAAa,KAAK,eAAe;AAAA,IACpC;AACA,WAAO;AACP,WAAO;AAAA,EACT;AAAA,EAEA,QAAQ;AACN,SAAK,WAAW,KAAK,IAAI;AACzB,SAAK,UAAU,QAAQ;AAAA,EACzB;AAAA,EAEA,CAAC,OAAO,aAAa,IAAiB;AACpC,WAAO;AAAA,EACT;AACF;","names":[]}