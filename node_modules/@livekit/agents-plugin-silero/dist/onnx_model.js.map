{"version":3,"sources":["../src/onnx_model.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { fileURLToPath } from 'node:url';\nimport { InferenceSession, Tensor } from 'onnxruntime-node';\n\nexport type SampleRate = 8000 | 16000;\n\nexport const newInferenceSession = (forceCPU: boolean) => {\n  return InferenceSession.create(fileURLToPath(new URL('silero_vad.onnx', import.meta.url).href), {\n    interOpNumThreads: 1,\n    intraOpNumThreads: 1,\n    executionMode: 'sequential',\n    executionProviders: forceCPU ? [{ name: 'cpu' }] : undefined,\n  });\n};\n\nexport class OnnxModel {\n  #session: InferenceSession;\n  #sampleRate: number;\n  #windowSizeSamples: number;\n  #contextSize: number;\n  #sampleRateNd: BigInt64Array;\n  #context: Float32Array;\n  // #state: Float32Array;\n  #rnnState: Float32Array;\n  #inputBuffer: Float32Array;\n\n  constructor(session: InferenceSession, sampleRate: SampleRate) {\n    this.#session = session;\n    this.#sampleRate = sampleRate;\n\n    switch (sampleRate) {\n      case 8000:\n        this.#windowSizeSamples = 256;\n        this.#contextSize = 32;\n        break;\n      case 16000:\n        this.#windowSizeSamples = 512;\n        this.#contextSize = 64;\n        break;\n    }\n\n    this.#sampleRateNd = BigInt64Array.from([BigInt(sampleRate)]);\n    this.#context = new Float32Array(this.#contextSize);\n    this.#rnnState = new Float32Array(2 * 1 * 128);\n    this.#inputBuffer = new Float32Array(this.#contextSize + this.#windowSizeSamples);\n  }\n\n  get sampleRate(): number {\n    return this.#sampleRate;\n  }\n\n  get windowSizeSamples(): number {\n    return this.#windowSizeSamples;\n  }\n\n  get contextSize(): number {\n    return this.#contextSize;\n  }\n\n  async run(x: Float32Array): Promise<number> {\n    this.#inputBuffer.set(this.#context, 0);\n    this.#inputBuffer.set(x, this.#contextSize);\n\n    return await this.#session\n      .run({\n        input: new Tensor('float32', this.#inputBuffer, [\n          1,\n          this.#contextSize + this.#windowSizeSamples,\n        ]),\n        state: new Tensor('float32', this.#rnnState, [2, 1, 128]),\n        sr: new Tensor('int64', this.#sampleRateNd),\n      })\n      .then((result) => {\n        // this.#state = result.output.data as Float32Array,\n        this.#context = this.#inputBuffer.subarray(0, this.#contextSize);\n        return (result.output!.data as Float32Array).at(0)!;\n      });\n  }\n}\n"],"mappings":"AAGA,SAAS,qBAAqB;AAC9B,SAAS,kBAAkB,cAAc;AAIlC,MAAM,sBAAsB,CAAC,aAAsB;AACxD,SAAO,iBAAiB,OAAO,cAAc,IAAI,IAAI,mBAAmB,YAAY,GAAG,EAAE,IAAI,GAAG;AAAA,IAC9F,mBAAmB;AAAA,IACnB,mBAAmB;AAAA,IACnB,eAAe;AAAA,IACf,oBAAoB,WAAW,CAAC,EAAE,MAAM,MAAM,CAAC,IAAI;AAAA,EACrD,CAAC;AACH;AAEO,MAAM,UAAU;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA,YAAY,SAA2B,YAAwB;AAC7D,SAAK,WAAW;AAChB,SAAK,cAAc;AAEnB,YAAQ,YAAY;AAAA,MAClB,KAAK;AACH,aAAK,qBAAqB;AAC1B,aAAK,eAAe;AACpB;AAAA,MACF,KAAK;AACH,aAAK,qBAAqB;AAC1B,aAAK,eAAe;AACpB;AAAA,IACJ;AAEA,SAAK,gBAAgB,cAAc,KAAK,CAAC,OAAO,UAAU,CAAC,CAAC;AAC5D,SAAK,WAAW,IAAI,aAAa,KAAK,YAAY;AAClD,SAAK,YAAY,IAAI,aAAa,IAAI,IAAI,GAAG;AAC7C,SAAK,eAAe,IAAI,aAAa,KAAK,eAAe,KAAK,kBAAkB;AAAA,EAClF;AAAA,EAEA,IAAI,aAAqB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,oBAA4B;AAC9B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,cAAsB;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,IAAI,GAAkC;AAC1C,SAAK,aAAa,IAAI,KAAK,UAAU,CAAC;AACtC,SAAK,aAAa,IAAI,GAAG,KAAK,YAAY;AAE1C,WAAO,MAAM,KAAK,SACf,IAAI;AAAA,MACH,OAAO,IAAI,OAAO,WAAW,KAAK,cAAc;AAAA,QAC9C;AAAA,QACA,KAAK,eAAe,KAAK;AAAA,MAC3B,CAAC;AAAA,MACD,OAAO,IAAI,OAAO,WAAW,KAAK,WAAW,CAAC,GAAG,GAAG,GAAG,CAAC;AAAA,MACxD,IAAI,IAAI,OAAO,SAAS,KAAK,aAAa;AAAA,IAC5C,CAAC,EACA,KAAK,CAAC,WAAW;AAEhB,WAAK,WAAW,KAAK,aAAa,SAAS,GAAG,KAAK,YAAY;AAC/D,aAAQ,OAAO,OAAQ,KAAsB,GAAG,CAAC;AAAA,IACnD,CAAC;AAAA,EACL;AACF;","names":[]}