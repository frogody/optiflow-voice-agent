{"version":3,"sources":["../src/stt.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport {\n  type AudioBuffer,\n  AudioByteStream,\n  AudioEnergyFilter,\n  Future,\n  log,\n  stt,\n} from '@livekit/agents';\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport { type RawData, WebSocket } from 'ws';\nimport type { STTLanguages, STTModels } from './models.js';\n\nconst API_BASE_URL_V1 = 'wss://api.deepgram.com/v1/listen';\n\nexport interface STTOptions {\n  apiKey?: string;\n  language?: STTLanguages | string;\n  detectLanguage: boolean;\n  interimResults: boolean;\n  punctuate: boolean;\n  model: STTModels;\n  smartFormat: boolean;\n  noDelay: boolean;\n  endpointing: number;\n  fillerWords: boolean;\n  sampleRate: number;\n  numChannels: number;\n  keywords: [string, number][];\n  keyterm: string[];\n  profanityFilter: boolean;\n  dictation: boolean;\n  diarize: boolean;\n  numerals: boolean;\n}\n\nconst defaultSTTOptions: STTOptions = {\n  apiKey: process.env.DEEPGRAM_API_KEY,\n  language: 'en-US',\n  detectLanguage: false,\n  interimResults: true,\n  punctuate: true,\n  model: 'nova-2-general',\n  smartFormat: true,\n  noDelay: true,\n  endpointing: 25,\n  fillerWords: false,\n  sampleRate: 16000,\n  numChannels: 1,\n  keywords: [],\n  keyterm: [],\n  profanityFilter: false,\n  dictation: false,\n  diarize: false,\n  numerals: false,\n};\n\nexport class STT extends stt.STT {\n  #opts: STTOptions;\n  #logger = log();\n  label = 'deepgram.STT';\n\n  constructor(opts: Partial<STTOptions> = defaultSTTOptions) {\n    super({\n      streaming: true,\n      interimResults: opts.interimResults ?? defaultSTTOptions.interimResults,\n    });\n    if (opts.apiKey === undefined && defaultSTTOptions.apiKey === undefined) {\n      throw new Error(\n        'Deepgram API key is required, whether as an argument or as $DEEPGRAM_API_KEY',\n      );\n    }\n\n    this.#opts = { ...defaultSTTOptions, ...opts };\n\n    if (this.#opts.detectLanguage) {\n      this.#opts.language = undefined;\n    } else if (\n      this.#opts.language &&\n      !['en-US', 'en'].includes(this.#opts.language) &&\n      [\n        'nova-2-meeting',\n        'nova-2-phonecall',\n        'nova-2-finance',\n        'nova-2-conversationalai',\n        'nova-2-voicemail',\n        'nova-2-video',\n        'nova-2-medical',\n        'nova-2-drivethru',\n        'nova-2-automotive',\n        'nova-3-general',\n      ].includes(this.#opts.model)\n    ) {\n      this.#logger.warn(\n        `${this.#opts.model} does not support language ${this.#opts.language}, falling back to nova-2-general`,\n      );\n      this.#opts.model = 'nova-2-general';\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async _recognize(_: AudioBuffer): Promise<stt.SpeechEvent> {\n    throw new Error('Recognize is not supported on Deepgram STT');\n  }\n\n  updateOptions(opts: Partial<STTOptions>) {\n    this.#opts = { ...this.#opts, ...opts };\n  }\n\n  stream(): SpeechStream {\n    return new SpeechStream(this, this.#opts);\n  }\n}\n\nexport class SpeechStream extends stt.SpeechStream {\n  #opts: STTOptions;\n  #audioEnergyFilter: AudioEnergyFilter;\n  #logger = log();\n  #speaking = false;\n  #resetWS = new Future();\n  label = 'deepgram.SpeechStream';\n\n  constructor(stt: STT, opts: STTOptions) {\n    super(stt);\n    this.#opts = opts;\n    this.closed = false;\n    this.#audioEnergyFilter = new AudioEnergyFilter();\n\n    this.#run();\n  }\n\n  async #run(maxRetry = 32) {\n    let retries = 0;\n    let ws: WebSocket;\n    while (!this.input.closed) {\n      const streamURL = new URL(API_BASE_URL_V1);\n      const params = {\n        model: this.#opts.model,\n        punctuate: this.#opts.punctuate,\n        smart_format: this.#opts.smartFormat,\n        dictation: this.#opts.dictation,\n        diarize: this.#opts.diarize,\n        numerals: this.#opts.numerals,\n        no_delay: this.#opts.noDelay,\n        interim_results: this.#opts.interimResults,\n        encoding: 'linear16',\n        vad_events: true,\n        sample_rate: this.#opts.sampleRate,\n        channels: this.#opts.numChannels,\n        endpointing: this.#opts.endpointing || false,\n        filler_words: this.#opts.fillerWords,\n        keywords: this.#opts.keywords.map((x) => x.join(':')),\n        keyterm: this.#opts.keyterm,\n        profanity_filter: this.#opts.profanityFilter,\n        language: this.#opts.language,\n      };\n      Object.entries(params).forEach(([k, v]) => {\n        if (v !== undefined) {\n          if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') {\n            streamURL.searchParams.append(k, encodeURIComponent(v));\n          } else {\n            v.forEach((x) => streamURL.searchParams.append(k, encodeURIComponent(x)));\n          }\n        }\n      });\n\n      ws = new WebSocket(streamURL, {\n        headers: { Authorization: `Token ${this.#opts.apiKey}` },\n      });\n\n      try {\n        await new Promise((resolve, reject) => {\n          ws.on('open', resolve);\n          ws.on('error', (error) => reject(error));\n          ws.on('close', (code) => reject(`WebSocket returned ${code}`));\n        });\n\n        await this.#runWS(ws);\n      } catch (e) {\n        if (retries >= maxRetry) {\n          throw new Error(`failed to connect to Deepgram after ${retries} attempts: ${e}`);\n        }\n\n        const delay = Math.min(retries * 5, 10);\n        retries++;\n\n        this.#logger.warn(\n          `failed to connect to Deepgram, retrying in ${delay} seconds: ${e} (${retries}/${maxRetry})`,\n        );\n        await new Promise((resolve) => setTimeout(resolve, delay * 1000));\n      }\n    }\n\n    this.closed = true;\n  }\n\n  updateOptions(opts: Partial<STTOptions>) {\n    this.#opts = { ...this.#opts, ...opts };\n    this.#resetWS.resolve();\n  }\n\n  async #runWS(ws: WebSocket) {\n    this.#resetWS = new Future();\n    let closing = false;\n\n    const keepalive = setInterval(() => {\n      try {\n        ws.send(JSON.stringify({ type: 'KeepAlive' }));\n      } catch {\n        clearInterval(keepalive);\n        return;\n      }\n    }, 5000);\n\n    const sendTask = async () => {\n      const samples100Ms = Math.floor(this.#opts.sampleRate / 10);\n      const stream = new AudioByteStream(\n        this.#opts.sampleRate,\n        this.#opts.numChannels,\n        samples100Ms,\n      );\n\n      for await (const data of this.input) {\n        let frames: AudioFrame[];\n        if (data === SpeechStream.FLUSH_SENTINEL) {\n          frames = stream.flush();\n        } else if (\n          data.sampleRate === this.#opts.sampleRate ||\n          data.channels === this.#opts.numChannels\n        ) {\n          frames = stream.write(data.data.buffer);\n        } else {\n          throw new Error(`sample rate or channel count of frame does not match`);\n        }\n\n        for await (const frame of frames) {\n          if (this.#audioEnergyFilter.pushFrame(frame)) {\n            ws.send(frame.data.buffer);\n          }\n        }\n      }\n\n      closing = true;\n      ws.send(JSON.stringify({ type: 'CloseStream' }));\n    };\n\n    const wsMonitor = new Promise<void>((_, reject) =>\n      ws.once('close', (code, reason) => {\n        if (!closing) {\n          this.#logger.error(`WebSocket closed with code ${code}: ${reason}`);\n          reject();\n        }\n      }),\n    );\n\n    const listenTask = async () => {\n      while (!this.closed && !closing) {\n        try {\n          await new Promise<RawData>((resolve) => {\n            ws.once('message', (data) => resolve(data));\n          }).then((msg) => {\n            const json = JSON.parse(msg.toString());\n            switch (json['type']) {\n              case 'SpeechStarted': {\n                // This is a normal case. Deepgram's SpeechStarted events\n                // are not correlated with speech_final or utterance end.\n                // It's possible that we receive two in a row without an endpoint\n                // It's also possible we receive a transcript without a SpeechStarted event.\n                if (this.#speaking) return;\n                this.#speaking = true;\n                this.queue.put({ type: stt.SpeechEventType.START_OF_SPEECH });\n                break;\n              }\n              // see this page:\n              // https://developers.deepgram.com/docs/understand-endpointing-interim-results#using-endpointing-speech_final\n              // for more information about the different types of events\n              case 'Results': {\n                const isFinal = json['is_final'];\n                const isEndpoint = json['speech_final'];\n\n                const alternatives = liveTranscriptionToSpeechData(this.#opts.language!, json);\n\n                // If, for some reason, we didn't get a SpeechStarted event but we got\n                // a transcript with text, we should start speaking. It's rare but has\n                // been observed.\n                if (alternatives[0] && alternatives[0].text) {\n                  if (!this.#speaking) {\n                    this.#speaking = true;\n                    this.queue.put({ type: stt.SpeechEventType.START_OF_SPEECH });\n                  }\n\n                  if (isFinal) {\n                    this.queue.put({\n                      type: stt.SpeechEventType.FINAL_TRANSCRIPT,\n                      alternatives: [alternatives[0], ...alternatives.slice(1)],\n                    });\n                  } else {\n                    this.queue.put({\n                      type: stt.SpeechEventType.INTERIM_TRANSCRIPT,\n                      alternatives: [alternatives[0], ...alternatives.slice(1)],\n                    });\n                  }\n                }\n\n                // if we receive an endpoint, only end the speech if\n                // we either had a SpeechStarted event or we have a seen\n                // a non-empty transcript (deepgram doesn't have a SpeechEnded event)\n                if (isEndpoint && this.#speaking) {\n                  this.#speaking = false;\n                  this.queue.put({ type: stt.SpeechEventType.END_OF_SPEECH });\n                }\n\n                break;\n              }\n              case 'Metadata': {\n                break;\n              }\n              default: {\n                this.#logger.child({ msg: json }).warn('received unexpected message from Deepgram');\n                break;\n              }\n            }\n          });\n        } catch (error) {\n          this.#logger.child({ error }).warn('unrecoverable error, exiting');\n          break;\n        }\n      }\n    };\n\n    await Promise.race([this.#resetWS.await, Promise.all([sendTask(), listenTask(), wsMonitor])]);\n    closing = true;\n    ws.close();\n    clearInterval(keepalive);\n  }\n}\n\nconst liveTranscriptionToSpeechData = (\n  language: STTLanguages | string,\n  data: { [id: string]: any },\n): stt.SpeechData[] => {\n  const alts: any[] = data['channel']['alternatives'];\n\n  return alts.map((alt) => ({\n    language,\n    startTime: alt['words'].length ? alt['words'][0]['start'] : 0,\n    endTime: alt['words'].length ? alt['words'][alt['words'].length - 1]['end'] : 0,\n    confidence: alt['confidence'],\n    text: alt['transcript'],\n  }));\n};\n"],"mappings":"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","names":["stt"]}